# Mapshot render CronJob - 4-hour fallback with checksum gating
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mapshot-render
  namespace: mapshot
spec:
  schedule: "0 */4 * * *"  # Every 4 hours
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      ttlSecondsAfterFinished: 86400  # Clean up after 24 hours
      template:
        spec:
          serviceAccountName: mapshot-render
          restartPolicy: OnFailure

          initContainers:
            # Copy latest save from Factorio pod and check if render needed
            - name: copy-save
              image: bitnami/kubectl:latest
              command: ["/bin/bash", "-c"]
              args:
                - |
                  set -e
                  echo "Finding Factorio pod..."
                  POD=$(kubectl get pods -n factorio -l app=factorio-factorio-server-charts -o jsonpath='{.items[0].metadata.name}')

                  if [ -z "$POD" ]; then
                    echo "ERROR: No Factorio pod found"
                    exit 1
                  fi

                  echo "Found pod: $POD"

                  # Find the most recent save file
                  SAVE=$(kubectl exec -n factorio "$POD" -- sh -c 'ls -t /factorio/saves/*.zip 2>/dev/null | head -1')

                  if [ -z "$SAVE" ]; then
                    echo "ERROR: No save files found"
                    exit 1
                  fi

                  echo "Copying save: $SAVE"
                  kubectl cp "factorio/$POD:$SAVE" /opt/factorio/saves/latest.zip

                  # Compute checksum
                  NEW_CHECKSUM=$(sha256sum /opt/factorio/saves/latest.zip | cut -d' ' -f1)
                  echo "Save checksum: $NEW_CHECKSUM"

                  # Check against previous checksum
                  if [ -f /mapshot/.last-render-checksum ]; then
                    OLD_CHECKSUM=$(cat /mapshot/.last-render-checksum)
                    echo "Previous checksum: $OLD_CHECKSUM"
                    if [ "$NEW_CHECKSUM" = "$OLD_CHECKSUM" ]; then
                      echo "SKIP_RENDER: Save unchanged since last render"
                      echo "skip" > /opt/factorio/saves/.render-status
                      exit 0
                    fi
                  fi

                  echo "Render needed (save changed or first render)"
                  echo "$NEW_CHECKSUM" > /opt/factorio/saves/.new-checksum
                  echo "render" > /opt/factorio/saves/.render-status
                  ls -la /opt/factorio/saves/
              volumeMounts:
                - name: saves
                  mountPath: /opt/factorio/saves
                - name: mapshot-data
                  mountPath: /mapshot

          containers:
            - name: render
              image: martydingo/mapshot:latest
              command: ["/bin/bash", "-c"]
              args:
                - |
                  set -euo pipefail

                  # Trap for unhandled failures - send Telegram alert
                  cleanup_on_error() {
                    local exit_code=$?
                    if [ $exit_code -ne 0 ]; then
                      # Only send if tokens are set (send_notification may not be defined yet)
                      if [ -n "${TELEGRAM_BOT_TOKEN:-}" ] && [ -n "${TELEGRAM_CHAT_ID:-}" ]; then
                        curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                          -d chat_id="${TELEGRAM_CHAT_ID}" \
                          -d parse_mode="HTML" \
                          -d text="❌ <b>Factorio Mapshot</b>%0ARender failed (exit code: $exit_code)" \
                          >/dev/null 2>&1 || true
                      fi
                    fi
                  }
                  trap cleanup_on_error EXIT

                  # =============================================================================
                  # PATH CONSTANTS - Single source of truth for all paths
                  # =============================================================================
                  PVC_ROOT="/mapshot"                                    # PVC mount point
                  FACTORIO_DIR="$PVC_ROOT/factorio"                      # Factorio installation
                  FACTORIO_BIN="$FACTORIO_DIR/bin/x64/factorio"          # Factorio binary
                  SCRIPT_OUTPUT="$FACTORIO_DIR/script-output"            # mapshot output root
                  VIEWER_DIR="$SCRIPT_OUTPUT/mapshot/latest"             # Where viewer files live
                  CHECKSUM_FILE="$PVC_ROOT/.last-render-checksum"        # Tracks last rendered save
                  SAVE_FILE="/opt/factorio/saves/latest.zip"             # Input save (from init container)
                  STATUS_FILE="/opt/factorio/saves/.render-status"       # Render decision from init
                  NEW_CHECKSUM_FILE="/opt/factorio/saves/.new-checksum"  # New checksum from init

                  # =============================================================================
                  # HELPER FUNCTIONS
                  # =============================================================================
                  log() { echo "[$(date '+%H:%M:%S')] $*"; }
                  error() { echo "[$(date '+%H:%M:%S')] ERROR: $*" >&2; }

                  validate_paths() {
                    log "Validating paths..."
                    local errors=0

                    # Check PVC is mounted
                    if [ ! -d "$PVC_ROOT" ]; then
                      error "PVC not mounted at $PVC_ROOT"
                      errors=$((errors + 1))
                    fi

                    # Check save file exists
                    if [ ! -f "$SAVE_FILE" ]; then
                      error "Save file not found: $SAVE_FILE"
                      errors=$((errors + 1))
                    fi

                    if [ $errors -gt 0 ]; then
                      error "Path validation failed with $errors errors"
                      return 1
                    fi

                    log "Path validation passed"
                    return 0
                  }

                  validate_render_output() {
                    log "Validating render output..."
                    local errors=0

                    # Check viewer directory exists
                    if [ ! -d "$VIEWER_DIR" ]; then
                      error "Viewer directory not found: $VIEWER_DIR"
                      log "Contents of $SCRIPT_OUTPUT:"
                      ls -laR "$SCRIPT_OUTPUT" 2>/dev/null || echo "(empty or missing)"
                      return 1
                    fi

                    # Check for render directories (d-XXXXX)
                    local render_dirs=$(find "$VIEWER_DIR" -maxdepth 1 -type d -name 'd-*' 2>/dev/null | wc -l)
                    if [ "$render_dirs" -eq 0 ]; then
                      error "No render directories (d-*) found in $VIEWER_DIR"
                      log "Contents of $VIEWER_DIR:"
                      ls -la "$VIEWER_DIR" 2>/dev/null || echo "(empty or missing)"
                      return 1
                    fi

                    # Find latest render directory
                    RENDER_DIR=$(ls -td "$VIEWER_DIR"/d-* 2>/dev/null | head -1)
                    RENDER_NAME=$(basename "$RENDER_DIR")
                    log "Latest render directory: $RENDER_NAME"

                    # Check required files exist
                    local required_files=("$VIEWER_DIR/index.html" "$VIEWER_DIR/viewer-"*".js" "$RENDER_DIR/mapshot.json")
                    for pattern in "${required_files[@]}"; do
                      if ! ls $pattern >/dev/null 2>&1; then
                        error "Required file not found: $pattern"
                        errors=$((errors + 1))
                      fi
                    done

                    if [ $errors -gt 0 ]; then
                      error "Render validation failed with $errors missing files"
                      log "Contents of $VIEWER_DIR:"
                      ls -la "$VIEWER_DIR"
                      log "Contents of $RENDER_DIR:"
                      ls -la "$RENDER_DIR" 2>/dev/null || echo "(missing)"
                      return 1
                    fi

                    log "Render validation passed"
                    return 0
                  }

                  create_symlinks() {
                    log "Creating symlinks for viewer compatibility..."

                    # The viewer constructs tile URLs as: {base}/s1zoom_N/tile_X_Y.jpg
                    # But mapshot puts them in: {base}/d-XXXXX/s1zoom_N/tile_X_Y.jpg
                    # Solution: symlink both mapshot.json AND all zoom directories

                    # 1. Symlink mapshot.json
                    local json_target="$RENDER_NAME/mapshot.json"
                    local json_link="$VIEWER_DIR/mapshot.json"
                    rm -f "$json_link"
                    ln -sf "$json_target" "$json_link"
                    log "Symlinked: mapshot.json -> $json_target"

                    # 2. Symlink all zoom directories (s1zoom_0, s1zoom_1, etc.)
                    for zoom_dir in "$RENDER_DIR"/s*zoom_*; do
                      if [ -d "$zoom_dir" ]; then
                        local zoom_name=$(basename "$zoom_dir")
                        local zoom_link="$VIEWER_DIR/$zoom_name"
                        rm -rf "$zoom_link"  # Remove existing symlink or directory
                        ln -sf "$RENDER_NAME/$zoom_name" "$zoom_link"
                        log "Symlinked: $zoom_name -> $RENDER_NAME/$zoom_name"
                      fi
                    done

                    # 3. Verify critical symlinks work
                    if [ ! -f "$json_link" ]; then
                      error "Symlink verification failed: $json_link"
                      return 1
                    fi

                    # List what we created
                    log "Symlinks created:"
                    ls -la "$VIEWER_DIR" | grep '^l'
                    return 0
                  }

                  send_notification() {
                    local status="$1"
                    local message="$2"

                    if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
                      return 0
                    fi

                    local emoji="✅"
                    [ "$status" = "error" ] && emoji="❌"

                    curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
                      -d chat_id="${TELEGRAM_CHAT_ID}" \
                      -d parse_mode="HTML" \
                      -d text="${emoji} <b>Factorio Mapshot</b>%0A${message}" \
                      >/dev/null || log "Warning: Telegram notification failed (non-fatal)"
                  }

                  # =============================================================================
                  # MAIN EXECUTION
                  # =============================================================================
                  log "=== Mapshot Render Job Started ==="

                  # Step 1: Check if render is needed (set by init container)
                  if [ -f "$STATUS_FILE" ]; then
                    STATUS=$(cat "$STATUS_FILE")
                    if [ "$STATUS" = "skip" ]; then
                      log "Skipping render - save unchanged since last render"
                      exit 0
                    fi
                  fi

                  # Step 2: Validate inputs
                  validate_paths || exit 1

                  # Step 3: Ensure Factorio is installed
                  if [ ! -f "$FACTORIO_BIN" ]; then
                    log "Downloading Factorio headless..."
                    curl -L "https://www.factorio.com/get-download/stable/headless/linux64?username=$FACTORIO_USERNAME&token=$FACTORIO_TOKEN" -o /tmp/factorio.tar.xz
                    log "Extracting to $PVC_ROOT..."
                    tar xf /tmp/factorio.tar.xz -C "$PVC_ROOT"
                    mkdir -p "$FACTORIO_DIR/mods"
                    echo '{}' > "$FACTORIO_DIR/mods/mod-list.json"
                    rm /tmp/factorio.tar.xz

                    if [ ! -f "$FACTORIO_BIN" ]; then
                      error "Factorio installation failed - binary not found at $FACTORIO_BIN"
                      exit 1
                    fi
                    log "Factorio installed successfully"
                  else
                    log "Factorio already installed at $FACTORIO_BIN"
                  fi

                  # Step 4: Run mapshot render
                  log "Running mapshot render..."
                  log "  Binary: $FACTORIO_BIN"
                  log "  Data dir: $FACTORIO_DIR"
                  log "  Save: $SAVE_FILE"
                  log "  Output: $SCRIPT_OUTPUT"

                  timeout ${MAPSHOT_INTERVAL:-3600} xvfb-run mapshot render \
                    --logtostderr \
                    --factorio_binary "$FACTORIO_BIN" \
                    --factorio_datadir "$FACTORIO_DIR" \
                    --work_dir "$FACTORIO_DIR" \
                    --area "${MAPSHOT_AREA:-all}" \
                    --resolution "${MAPSHOT_RESOLUTION:-2048}" \
                    --jpgquality "${MAPSHOT_JPEG_QUALITY:-90}" \
                    --surface _all_ \
                    -v 5 \
                    "$SAVE_FILE"

                  # Step 5: Validate render output
                  validate_render_output || {
                    send_notification "error" "Render failed - output validation failed"
                    exit 1
                  }

                  # Step 6: Create symlinks for viewer compatibility
                  create_symlinks || {
                    send_notification "error" "Render failed - symlink creation failed"
                    exit 1
                  }

                  # Step 7: Update checksum to prevent re-rendering same save
                  if [ -f "$NEW_CHECKSUM_FILE" ]; then
                    cp "$NEW_CHECKSUM_FILE" "$CHECKSUM_FILE"
                    log "Checksum updated"
                  fi

                  # Step 8: Final summary
                  log "=== Render Complete ==="
                  log "Viewer URL: https://mapshot.codeofficer.com/mapshot/latest/"
                  log "Render dir: $RENDER_NAME"
                  log "Files:"
                  ls -la "$VIEWER_DIR" | head -15

                  # Step 9: Sync to NAS for Mac access
                  log "Syncing to NAS..."
                  NAS_DEST="/nas/mapshot/renders"
                  mkdir -p "$NAS_DEST"
                  # Copy the latest viewer files to NAS
                  cp -r "$VIEWER_DIR"/* "$NAS_DEST/" 2>/dev/null || true
                  log "NAS sync complete: $NAS_DEST"
                  ls -la "$NAS_DEST" | head -10

                  # Step 10: Cleanup old renders (keep latest only)
                  log "Cleaning up old renders..."
                  # Clean NAS renders
                  cd "$NAS_DEST"
                  NAS_LATEST=$(ls -td d-* 2>/dev/null | head -1)
                  if [ -n "$NAS_LATEST" ]; then
                    OLD_RENDERS=$(ls -d d-* 2>/dev/null | grep -v "^$NAS_LATEST$" || true)
                    if [ -n "$OLD_RENDERS" ]; then
                      echo "$OLD_RENDERS" | xargs -r rm -rf
                      log "Removed old NAS renders: $(echo "$OLD_RENDERS" | wc -l) folders"
                    fi
                  fi
                  # Clean PVC renders
                  cd "$VIEWER_DIR"
                  PVC_LATEST=$(ls -td d-* 2>/dev/null | head -1)
                  if [ -n "$PVC_LATEST" ]; then
                    OLD_PVC_RENDERS=$(ls -d d-* 2>/dev/null | grep -v "^$PVC_LATEST$" || true)
                    if [ -n "$OLD_PVC_RENDERS" ]; then
                      echo "$OLD_PVC_RENDERS" | xargs -r rm -rf
                      log "Removed old PVC renders: $(echo "$OLD_PVC_RENDERS" | wc -l) folders"
                    fi
                  fi
                  # Remove stale zoom symlinks (point to deleted renders)
                  find "$VIEWER_DIR" -maxdepth 1 -type l ! -xtype f ! -xtype d -delete 2>/dev/null || true

                  # Step 11: Send success notification
                  send_notification "success" "New map render available%0Ahttps://mapshot.codeofficer.com/mapshot/latest/"
              env:
                - name: FACTORIO_USERNAME
                  valueFrom:
                    secretKeyRef:
                      name: factorio-credentials
                      key: username
                - name: FACTORIO_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: factorio-credentials
                      key: token
                - name: MAPSHOT_MODE
                  value: "render"
                - name: FACTORIO_SAVE
                  value: "/opt/factorio/saves/latest.zip"
                - name: MAPSHOT_INTERVAL
                  value: "3600"  # 1 hour timeout for render
                - name: MAPSHOT_AREA
                  value: "all"
                - name: MAPSHOT_JPEG_QUALITY
                  value: "90"
                - name: MAPSHOT_ROOT_DIRECTORY
                  value: "/mapshot"
                # Optional Telegram notification (secret may not exist)
                - name: TELEGRAM_BOT_TOKEN
                  valueFrom:
                    secretKeyRef:
                      name: telegram-credentials
                      key: bot-token
                      optional: true
                - name: TELEGRAM_CHAT_ID
                  valueFrom:
                    secretKeyRef:
                      name: telegram-credentials
                      key: chat-id
                      optional: true
              volumeMounts:
                - name: saves
                  mountPath: /opt/factorio/saves
                - name: mapshot-data
                  mountPath: /mapshot
                - name: nas-dest
                  mountPath: /nas
              resources:
                requests:
                  memory: "2Gi"
                  cpu: "1"
                limits:
                  memory: "4Gi"
                  cpu: "2"

          volumes:
            - name: saves
              emptyDir: {}
            - name: mapshot-data
              persistentVolumeClaim:
                claimName: mapshot-data
            - name: nas-dest
              nfs:
                server: 10.20.10.20
                path: /volume/567898ba-8471-4adb-9be9-d3e1f96fa7ba/.srv/.unifi-drive/K3sStorage/.data

          # Schedule on control plane nodes (same as Factorio for local-path PVC locality)
          nodeSelector:
            node-role.kubernetes.io/control-plane: "true"
          tolerations:
            - key: "node-role.kubernetes.io/control-plane"
              operator: "Exists"
              effect: "NoSchedule"
