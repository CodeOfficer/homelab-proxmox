#!/usr/bin/env python3
"""
Stop Hook - Automatic Prompt Logging
Runs after every Claude response to log the interaction.
"""

import json
import sys
import os
from datetime import datetime
from pathlib import Path

def get_project_root():
    """Get the project root directory."""
    hook_dir = Path(__file__).parent
    return hook_dir.parent.parent

def extract_last_interaction(transcript_path):
    """Extract the last user prompt and assistant response from JSONL transcript."""
    last_user = None
    last_assistant = None

    with open(transcript_path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                entry = json.loads(line)
                msg = entry.get('message', {})
                role = msg.get('role', '')

                if role == 'user':
                    content = msg.get('content', '')
                    if isinstance(content, str):
                        last_user = content.strip()[:500]

                elif role == 'assistant':
                    content = msg.get('content', [])
                    if isinstance(content, list):
                        text_parts = [b.get('text', '') for b in content if isinstance(b, dict) and b.get('type') == 'text']
                        last_assistant = ' '.join(text_parts).strip()

            except json.JSONDecodeError:
                continue

    return last_user, last_assistant

def summarize_response(response, max_length=100):
    """Create a one-line summary of the response."""
    if not response:
        return "No response captured"

    first_line = response.split('\n')[0].strip()
    first_line = first_line.lstrip('#').lstrip('*').lstrip('-').strip()

    if len(first_line) > max_length:
        first_line = first_line[:max_length-3] + "..."

    return first_line if first_line else "Response logged"

def append_to_log(project_root, user_prompt, response_summary):
    """Append entry to logs/prompts.log."""
    log_dir = project_root / 'logs'
    log_file = log_dir / 'prompts.log'

    log_dir.mkdir(exist_ok=True)

    if not log_file.exists():
        with open(log_file, 'w') as f:
            f.write("# Prompt Log\n")
            f.write("# Format: [TIMESTAMP] User: \"<prompt>\"\n")
            f.write("#         → Response: <brief summary>\n\n")

    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    clean_prompt = user_prompt.replace('\n', ' ').replace('"', "'")[:200] if user_prompt else "No prompt captured"
    entry = f'[{timestamp}] User: "{clean_prompt}"\n→ Response: {response_summary}\n\n'

    with open(log_file, 'a') as f:
        f.write(entry)

def main():
    try:
        hook_input = json.load(sys.stdin)
        transcript_path = hook_input.get('transcript_path')

        if not transcript_path or not os.path.exists(transcript_path):
            return

        project_root = get_project_root()
        last_user, last_assistant = extract_last_interaction(transcript_path)

        if not last_user:
            return

        summary = summarize_response(last_assistant)
        append_to_log(project_root, last_user, summary)

    except Exception:
        pass  # Fail silently

if __name__ == '__main__':
    main()
